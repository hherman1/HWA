{- (c) Hunter Herman 2015
 -
 - Problem: given a collection of words, find the longest sequence where each 
 - member of the sequence is 1 letter larger than the previous.
 -
 -
 - Method: 
 - 	1. Break the text file down into its words, splitting on new lines.
 - 	2. Put the words into a data structure mapping the composition of
 - 	   words to their original text, storing only 1 word per composition.
 - 	3. Transform that data structure into a Graph, implemented by a 
 - 	   library on a Patricia Tree.
 - 	4. Find the topological sorting of that graph, another library function.
 - 	5. Find the longest path through the graph for the first 100 elements
 - 	   of the topologically sorted list of nodes.
 - 	6. Find the longest path among these candidate longest paths.
 - 	7. Convert the final longest path to string form, using the 
 - 	   Composition -> String map we generated earlier. 
 -
 -
 - Runtime & Details:
 - 	There are a variety of independant algorithms running here:
 -
 - 	1. getComposition
 - 	   	This is the function which converts any word into its 
 - 	   breakdown by letters. For each word, if n is the length
 - 	   of the word, this function will run in sum(log(i)) as i goes
 - 	   from 0 to n. Mathematica claims this is equivalent to 
 - 	   Log[Pochhammer[1,n]], which appears to be unreducible.
 -
 - 	   It should be noted that this is the consequence of the way 
 - 	   Data.Map is being used in this circumstance. The composition is 
 - 	   generated by folding over the string, and inserting with addition
 - 	   into the map for each character. Insertion is O(log n) in the
 - 	   library Data.Map. The specifics of inserting with addition are 
 - 	   available online.
 - 	   	Efficiency: O(Log(Pochhammer(1,n)))
 -
 - 	2. getPath	
 - 		This function takes a Node reference, and a Vector containing
 - 	   the outputs of the "predecessor" array from the shortestPath 
 - 	   function. This function does not run proportionate to the size of the 
 - 	   Array, but if we take n to be the size of the longest path, it runs
 - 	   in O(n). 
 - 	   	Efficiency: O(n), where n is the length of the longest path.
 - 	   	Average Efficiency: O(1)
 -
 - 	3. genNeighbors
 - 		This function generates the Compositions a composition can 
 - 	   possibly link to. It runs in constant time- for any given composition
 - 	   it simply generates the composition with an increment for each possible
 - 	   character. It would be T = 27.
 - 	   	Efficiency: O(1)
 -	
 - 	4. initGraph
 - 		This function assembles the graph from the list of edges and nodes.
 - 	   I do not know the efficiency of this function and it would be impossible
 - 	   to detect without delving into the internals of the Graph libray. However
 - 	   it does depend on a function we can detect the efficiency of, findEdges.
 - 		Efficiency: O(initGraph) + O(log(n))
 -
 - 	5. findEdges
 - 		This function takes a Node, a Composition, a map from Compositions
 - 	   to Nodes, and generates a list of outgoing edges for that Node. It uses
 - 	   genNeighbors to generate possible targets, and then looks these possible
 - 	   targets up in the Composition -> Node map. Lookups in this map are O(log(n))
 - 	   where n is the length of the map. Since genNeighbors is O(1), and this
 - 	   function is O(genNeighbors) * O(lookup), the overall order is 
 -	   O(1) * O(log(n)) = O(log(n)).
 -	   	Efficiency: O(log(n))
 -
 -	6. longestPaths
 -		This function takes two empty arrays, representing distances and 
 -	   predecessors, it takes a list of Nodes topologically sorted, and it
 -	   take a Graph with nodes labeled as Compositions. The algorithm is
 -	   a published algorithm, available at:
 - 	   https://en.wikipedia.org/wiki/Topological_sorting#Application_to_shortest_path_finding
 - 	  	It has been adapted for use in finding the longest path. The adaption is simple,
 - 	   requiring only a change of the comparison function. Given the topological
 - 	   sort, this algorithm runs in linear time, O(n + e) where n is the 
 - 	   number of nodes in the graph and e is the number of edges.
 - 	   	Efficiency: O(n + e)
 -
 - 	7. topsort
 - 		This is a function from the Graph library, however since the runtime
 - 	   of longestPaths depends on having a topologically sorted list of nodes
 - 	   as input, I have decided it is worth including an efficiency analysis of
 - 	   this function:
 -	   https://en.wikipedia.org/wiki/Topological_sorting#Complexity
 -	   	It should be noted that the library (somehow) uses a depth-first search as a
 -	   means of calculating the topological sort. It is unclear what the run-
 -	   -time of this implementation should be. Although it is unlikely to be 
 -	   O(log^2(n)), as wikipedia reports the efficiency of this function to be.
 -	   	Efficiency: ~O(log^2(n))
 -
 -	8. genLongestPath
 -		This function is something of a middle man, taking the work done
 -	   by longestPaths and converting it from its vector output to a sequence
 -	   of nodes. It does so by freezing the outputted vectors making them more
 -	   easily manipulated. Freezing is O(n), and is a function in the library
 -	   Data.Vector. It runs maxIndex on the distance vector, passing the result
 -	   into getPath as the Node, and passing the frozen predecessors Vector as
 -	   the Vector Node.
 -	   	Efficiency: O(n + e)
 -	   	
 -	9. maxIndex
 -		This is a library function for Data.Vector. It runs in O(n) and finds
 -	   the index of the maximum-valued element in the vector. 
 -	   	Effficiency: O(n)
 -
 -	10. genLongestPaths - DEPRECATED
 -		After contemplating this algorithm, it appears unnecesarry. Commented
 -	    out code was deprecated with this function.
 -		This function runs genLongestPath on n elements of a list of Nodes.
 -	    Therefore its efficiency is n * O(genLongestPath) = O(n * n) = O(n^2)
 -	    	Efficiency: O(n^2)
 -	    	Benchmark on n = 1: ~300ms
 -	
 -	11. stringsToMap
 -		This function uses a Data.Vectors function "fromList" to assemble a 
 -	    Map from Compositions to Texts, which has O(n log(n)). If n is the number 
 -	    of input Texts, then we have the efficiency equals to O(fromList) +
 -	    O(getComposition) * (O(map) + O(zip)). Map and zip are both O(n), analysis 
 -	    for these functions is probably available online. So we have O(n log(n)) +
 -	    O(1) * O(n) + O(1) * O(n). The components of this efficiency less than 
 -	    n log(n) are inconsequential. So ultimately, the efficiency for this function
 -	    is O(n log(n)).
 -	    	Efficiency: O(n log(n))
 -	12. compToNodeMap
 -		This function converts between map types. It takes O(map), which is a linear
 -	    function.
 -	    	Efficiency: O(n)
 -
 -	13. compGraphFromMap
 -		This function generates a graph from a Composition map. It takes O(initgraph)
 -	    + O(compToNodeMap) = O(initGraph) + O(n)
 -	    	Efficiency: O(initGraph) + O(n)
 -	
 -	14. lines
 -		This is a function in Prelude that splits text on newlines.
 -		Efficiency: O(n)
 -	15. maximumBy
 -		This is a function in Data.Ord the finds the largest element in a list 
 -	    from a given comparison function.
 -	    	Efficiency: O(n)
 -	16. pathToStrings
 -		This function takes a list of nodes, a graph, and a map from Compositions
 -	    to strings, and outputs a list of strings. Its highest cost functions are 'lab',
 -	    and 'lookup'. These are functions from the Graph library and Data.Map, respectively.
 -	    O(lab) is unknown, and O(lookup) is O(log n), where n is the length of the Map. 
 -	    The other operations in this function act on a considerably smaller array, but are
 -	    O(m) where m is the length of the inputted list of nodes.
 -	    	Efficiency: O(log n) + O(m)
 -	    	Average Efficiency: O(log n)
 -
 - 	    The final runtime of the program is a summation of these functions' runtime:
 -
 - 		O(lines) + O(stringsToMap) + O(compGraphFromMap) + O(topsort) 
 - 		+ O(genLongestPath) + O(maximumBy) + O(pathToStrings)
 -
 - 	    =	O(n) + O(n log(n)) + (O(initGraph) + O(n)) + O(log^2 (n)) 
 - 	    	+ O(n + e) + O(n) + O(log n)
 -
 - 	    =	O(n log(n))
 -
 - Changes made during development:
 -
 - 		My first strategy had O(n^3) graph generation. One of the things I was 
 -	doing was searching the graph to find each neighbor, which was O(n^2). I changed this 
 -	to a system where I generate the neighbors up front and search for them in the list
 -	before using them in the graph. This was very useful.
 -		I also made a number of major changes very on as I was trying to figure out 
 -	what data structures I would use. At first I was considering my own Map implementation,
 -	then Data.Map.Strict, then Data.Map.Lazy. Also, I originally stored the corpus in a 
 -	String before switching to Text for theoretically substantial gains. My original Graph
 -	implementation was Data.Graph, which made building graphs very easy, but was thoroughly
 -	featureless. It also did not support directed graphs, and the algorithm for finding the 
 -	longest path is only linear on directed acyclic graphs. 
 -		I also found a much neater way of arranging the maps I needed over time,
 -	deciding ultimately to convert between different map types rather than cram all data
 -	into a single map. This didn't change the asymptotics, which is what ultimately won me over.
 -		Finally, I was doing a lot of redundant work in finding the longest path. I 
 -	believed the algorithm I was using only worked for the source, however due to a small
 -	bug in my implementation (and attempts at debugging) I was able to realize that the 
 -	algorithm actually detects the longest path for any node. 
 -		I'm sure there were other changes (this HW took me many hours), but they were mostly
 -	small. 
 -}


module Lib where

import Criterion.Main
import Prelude hiding (read,lookup)
import Data.Foldable (maximumBy)
import Data.Ord (comparing)
import Data.Text (lines,Text)
import qualified Data.Text as T (foldr)
import qualified Data.Text.IO as TIO (readFile)
import Data.Map hiding (foldr,map,(!))
import Data.Graph.Inductive.Graph
import Data.Graph.Inductive.PatriciaTree
import Data.Graph.Inductive.Query.DFS
import Data.Graph.Inductive.Query.SP.DAG
import qualified Data.Map.Lazy as ML hiding (map,(!))
import Control.Monad
import Data.Maybe (catMaybes)
import Data.Tuple (swap)
import Data.Vector (freeze,Vector,maxIndex,(!))


type Composition = ML.Map Char Int
type Weight = Int
type CompGraph gr = gr Composition Int
type Topsort = [Node]

smallwords = "C:/Users/thepr/Dropbox/School Work/HW/Algorithms/HWA/WORDS.txt"
hugewords = "C:/Users/thepr/Dropbox/School Work/HW/Algorithms/HWA/HUGE_WORDS.txt"

text = Data.Text.lines <$> TIO.readFile hugewords
textGraph = compGraph 1 <$> text

defaultWeight :: Weight
defaultWeight = 1 

benchmarks :: Bool
benchmarks = False

--searchCount :: Int
--searchCount = 1000

main = do
	pureText <- text
	let 	wordMap = stringsToMap pureText
		wordGraph = compGraphFromMap 1 wordMap
		ts = topsort wordGraph
	
	if benchmarks then defaultMain 
		[bgroup "Graph generation" 
					[--bench "1" $ nf compGraph $ take 1 pureText
					bench "500" $ nf (compGraph 1) $ take 500 pureText
					,bench "1000" $ nf (compGraph 1) $ take 1000 pureText
					]
--		,bgroup "longestPaths" 	[ bench "1" $ nfIO (genLongestPaths 1 ts wordGraph)
--					, bench "5" $ nfIO (genLongestPaths 5 ts wordGraph)
--					, bench "10" $ nfIO (genLongestPaths 10 ts wordGraph)
--					]
		]
	else return ()

	longestPath <- longestPath (length ts) ts wordGraph
	let	output = pathToStrings wordMap wordGraph longestPath
	putStrLn $ show output

--genLongestPaths :: Graph gr => Int -> Topsort -> CompGraph gr -> IO [[Node]]
--genLongestPaths n t graph = do
--	sequence $ map (\n -> genLongestPath n t graph) $ take n t
	

pathToStrings :: Graph gr => Map Composition Text -> CompGraph gr -> [Node] -> [Text]
pathToStrings wordMap wordGraph maxPath = 
	catMaybes $ map (\m -> (flip lookup) wordMap =<< lab wordGraph m) maxPath

getPath :: Node -> Vector Node -> [Node]
getPath n predecessors  = let p = predecessors ! n in
	if p == -1 then
		[]
	else
		p : getPath p predecessors

compGraphFromMap :: Weight -> Map Composition a -> CompGraph Gr
compGraphFromMap w = initGraph w . compToNodeMap

compGraph :: Weight -> [Text] -> CompGraph Gr
compGraph w ws = initGraph w . compToNodeMap . stringsToMap $ ws

getComposition :: Text -> Composition
getComposition t = T.foldr (\c -> insertWith (+) c 1) ML.empty t


stringsToMap :: [Text] -> Map Composition Text
stringsToMap ts = fromList $ zip (map getComposition ts) ts

compToNodeMap :: Map Composition a -> Map Composition Node
compToNodeMap = snd . mapAccum (\x _ -> (tail x,head x)) [1..] 


initGraph :: Graph gr => Weight -> Map Composition Node -> CompGraph gr
initGraph w mcomp = mkGraph (map swap $ assocs mcomp) $
	concat . map (\(comp,n) -> findEdges w n comp mcomp) $ assocs mcomp

findEdges :: Weight -> Node -> Composition -> Map Composition Node -> [LEdge Weight]
findEdges w n comp mcomp = zip3 (repeat n) (findNeighbors comp mcomp) (repeat w)

findNeighbors :: Composition -> Map Composition Node -> [Node]
findNeighbors comp mcomp = catMaybes . map ((flip ML.lookup) mcomp) $ genNeighbors comp 

genNeighbors :: MonadPlus m => Composition -> m Composition
genNeighbors comp = foldr (\c -> mplus (return $ insertWith (+) c 1 comp)) mzero ['a'..'z']


